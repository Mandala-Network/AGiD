---
phase: 05-shad-semantic-memory
plan: 02
type: execute
---

<objective>
Fix Shad integration by replacing non-functional HTTP API approach with secure temp vault pattern.

Purpose: Enable complex multi-step reasoning tasks (10% of use cases) that benefit from Shad's RLM capabilities.
Output: Working ShadTempVaultExecutor that decrypts vault to temp dir, runs Shad with filesystem retriever, cleans up.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-shad-semantic-memory/05-RESEARCH.md

# Existing (non-functional) code to replace
@src/shad/shad-integration.ts

# Vault implementations
@src/vault/local-encrypted-vault.ts
@src/shad/encrypted-vault.ts

**Critical finding from research:**
The existing AGIdentityShadBridge uses `--retriever api` and `--retriever-url` which DO NOT EXIST in Shad.
Actual Shad retrievers: `auto`, `qmd`, `filesystem` only.
Must use temp vault approach: decrypt to temp dir, run Shad with --retriever filesystem, cleanup.

**Security requirements:**
- Temp directory with 0o700 permissions (owner only)
- Always cleanup in finally block (even on error)
- Never persist decrypted content
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ShadTempVaultExecutor with secure temp vault pattern</name>
  <files>src/shad/shad-temp-executor.ts</files>
  <action>
Create new executor that actually works with Shad:

1. Create `src/shad/shad-temp-executor.ts`:
   - Class `ShadTempVaultExecutor`
   - Constructor takes vault (LocalEncryptedVault or EncryptedShadVault) and config
   - Method `execute(task: string, options?: ShadExecuteOptions): Promise<ShadResult>`

2. Implement secure temp vault pattern:
   ```typescript
   async execute(task: string, options?: ShadExecuteOptions): Promise<ShadResult> {
     // 1. Create secure temp directory (0o700 permissions)
     const tempDir = await mkdtemp(join(tmpdir(), 'agid-shad-'));
     await chmod(tempDir, 0o700);

     try {
       // 2. Decrypt all documents to temp vault
       const docs = await this.vault.list();
       for (const docPath of docs) {
         const content = await this.vault.read(docPath);
         if (content) {
           const tempPath = join(tempDir, docPath);
           await mkdir(dirname(tempPath), { recursive: true });
           await writeFile(tempPath, content, 'utf-8');
         }
       }

       // 3. Run Shad with filesystem retriever (NOT api!)
       return await this.runShad(task, tempDir, options);
     } finally {
       // 4. ALWAYS cleanup (security critical)
       await rm(tempDir, { recursive: true, force: true });
     }
   }
   ```

3. Fix Shad CLI args (use actual flags that exist):
   ```typescript
   const args = [
     '-m', 'shad.cli',
     'run', task,
     '--vault', tempDir,           // Point to temp decrypted vault
     '--retriever', 'filesystem',  // NOT 'api' - that doesn't exist!
     '--strategy', options?.strategy ?? 'research',
     '--max-depth', String(options?.maxDepth ?? 3),
     '--max-time', String(options?.maxTime ?? 300),
     '--json',
   ];
   ```

4. Add `checkShadAvailable()` method that returns { available: boolean, version?: string }

Do NOT keep the HTTP server approach - it cannot work with actual Shad.
  </action>
  <verify>npm run build passes, ShadTempVaultExecutor class exists</verify>
  <done>ShadTempVaultExecutor created with correct Shad CLI args and secure cleanup</done>
</task>

<task type="auto">
  <name>Task 2: Update exports and add graceful fallback</name>
  <files>src/shad/index.ts, src/shad/shad-integration.ts, src/index.ts</files>
  <action>
1. Update src/shad/index.ts:
   - Export ShadTempVaultExecutor
   - Export createShadExecutor factory function
   - Keep AGIdentityShadBridge export but mark as @deprecated

2. Add deprecation notice to AGIdentityShadBridge in shad-integration.ts:
   ```typescript
   /**
    * @deprecated Use ShadTempVaultExecutor instead. This class uses non-existent
    * Shad CLI flags (--retriever api) and will not work with actual Shad installations.
    * Kept for backwards compatibility but will be removed in future versions.
    */
   ```

3. Create factory function in src/shad/index.ts:
   ```typescript
   export async function createShadExecutor(config: {
     vault: LocalEncryptedVault | EncryptedShadVault;
     userPublicKey?: string;
     shadConfig?: Partial<ShadConfig>;
   }): Promise<ShadTempVaultExecutor | null> {
     const executor = new ShadTempVaultExecutor(config);
     const available = await executor.checkShadAvailable();
     if (!available.available) {
       console.warn('Shad not available:', available.error);
       return null; // Graceful fallback - caller uses memory server instead
     }
     return executor;
   }
   ```

4. Update src/index.ts exports:
   - Add ShadTempVaultExecutor, createShadExecutor

5. Add basic test in src/shad/shad-temp-executor.test.ts:
   - Test checkShadAvailable returns { available: false } when Shad not installed
   - Test execute throws if vault not provided
   - Mock the actual Shad execution (don't require Shad installed for tests)
  </action>
  <verify>npm run build && npm test passes</verify>
  <done>ShadTempVaultExecutor exported, AGIdentityShadBridge deprecated, graceful fallback works</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npm test` passes all tests
- [ ] ShadTempVaultExecutor uses correct Shad CLI flags (--retriever filesystem, NOT api)
- [ ] Temp vault cleanup always happens (in finally block)
- [ ] AGIdentityShadBridge marked as deprecated
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Shad integration uses actual working CLI flags
- Secure temp vault pattern with guaranteed cleanup
</success_criteria>

<output>
After completion, create `.planning/phases/05-shad-semantic-memory/05-02-SUMMARY.md`
</output>
