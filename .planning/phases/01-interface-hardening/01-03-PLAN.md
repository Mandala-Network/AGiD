---
phase: 01-interface-hardening
plan: 03
type: execute
---

<objective>
Fix error handling: CurvePoint silent failures and vault decryption error type distinction.

Purpose: Surface errors properly so failures are detected and debuggable rather than silently corrupting state.
Output: Proper error propagation in CurvePoint operations, distinct error types in vault decryption.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONCERNS.md
@.planning/codebase/CONVENTIONS.md

**Key files:**
@src/team/team-vault.ts
@src/team/secure-team-vault.ts
@src/vault/local-encrypted-vault.ts

**Issues being addressed:**
- Silent CurvePoint Failures (CONCERNS.md): New team members cannot decrypt documents after being added - empty catch blocks with console.warn only
- Vault Decryption Error Handling (CONCERNS.md): Broad catch block doesn't distinguish ENOENT, EACCES, decryption errors
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix silent CurvePoint failures in TeamVault</name>
  <files>src/team/team-vault.ts</files>
  <action>
In `reencryptDocumentsForNewMember()` (lines 740-758) and `reencryptDocumentsAfterMemberRemoval()` (lines 776-793), the catch blocks silently swallow errors with just console.warn.

Current (problematic):
```typescript
} catch (error) {
  console.warn(`Could not add participant to document ${doc.path}, skipping`);
}
```

Fix by collecting failures and throwing at the end if any occurred:

```typescript
private async reencryptDocumentsForNewMember(
  teamId: string,
  newMemberPublicKey: string
): Promise<void> {
  const team = await this.getTeam(teamId);
  if (!team) return;

  const teamDocs: TeamDocument[] = [];
  for (const [key, doc] of this.documents) {
    if (key.startsWith(`${teamId}:`)) {
      teamDocs.push(doc);
    }
  }

  const failures: Array<{ path: string; error: Error }> = [];

  for (const doc of teamDocs) {
    const fullCiphertext = [...doc.header, ...doc.encryptedContent];

    try {
      const updatedHeader = await this.curvePoint.addParticipant(
        fullCiphertext,
        team.protocolID as any,
        team.keyID,
        newMemberPublicKey
      );

      doc.header = updatedHeader;
      this.documents.set(`${teamId}:${doc.path}`, doc);
    } catch (error) {
      failures.push({
        path: doc.path,
        error: error instanceof Error ? error : new Error(String(error))
      });
    }
  }

  if (failures.length > 0) {
    const failedPaths = failures.map(f => f.path).join(', ');
    throw new Error(
      `Failed to add participant to ${failures.length} document(s): ${failedPaths}. ` +
      `First error: ${failures[0].error.message}`
    );
  }
}
```

Apply same pattern to `reencryptDocumentsAfterMemberRemoval()`.

WHY: Silent failures leave state inconsistent - new member added to team but can't decrypt some documents. Caller needs to know operation partially failed.
  </action>
  <verify>Run `npm run build` - no type errors.</verify>
  <done>CurvePoint failures in TeamVault are collected and thrown as aggregate error</done>
</task>

<task type="auto">
  <name>Task 2: Fix silent CurvePoint failures in SecureTeamVault</name>
  <files>src/team/secure-team-vault.ts</files>
  <action>
Apply same fix to SecureTeamVault's `reencryptDocumentsForNewMember()` (around lines 820-851) and `reencryptDocumentsAfterMemberRemoval()` (around lines 853-882).

Use same pattern: collect failures, throw aggregate error at end.

WHY: SecureTeamVault has same bug - silent failures leave inconsistent state.
  </action>
  <verify>Run `npm run build` - no type errors.</verify>
  <done>CurvePoint failures in SecureTeamVault are collected and thrown as aggregate error</done>
</task>

<task type="auto">
  <name>Task 3: Distinguish vault decryption error types</name>
  <files>src/vault/local-encrypted-vault.ts</files>
  <action>
Find the vault decryption error handling (around lines 303-320 per CONCERNS.md). The issue is a broad catch block that doesn't distinguish:
- ENOENT (file not found)
- EACCES (permission denied)
- Decryption errors (corrupted file, wrong key)

Current pattern (problematic):
```typescript
try {
  // decrypt file
} catch (error) {
  // treats all errors the same
}
```

Fix by checking error types:
```typescript
try {
  // decrypt file
} catch (error) {
  if (error instanceof Error) {
    const nodeError = error as NodeJS.ErrnoException;
    if (nodeError.code === 'ENOENT') {
      throw new Error(`File not found: ${filePath}`);
    }
    if (nodeError.code === 'EACCES') {
      throw new Error(`Permission denied: ${filePath}`);
    }
    // Check for decryption-specific errors
    if (error.message.includes('decrypt') || error.message.includes('cipher')) {
      throw new Error(`Decryption failed for ${filePath}: file may be corrupted or encrypted with different key`);
    }
  }
  throw error; // Re-throw unknown errors
}
```

Locate the actual code and apply appropriate error distinction. The goal is: caller can distinguish "file doesn't exist" from "file is corrupted".

WHY: Currently corrupted encrypted files are silently treated as "not encrypted", masking data corruption.
  </action>
  <verify>Run `npm run build` - no type errors. Run `npm test` - existing tests pass.</verify>
  <done>Vault decryption distinguishes file-not-found, permission, and decryption errors</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npm test` passes all existing tests
- [ ] `grep -r "console.warn.*Could not" src/team/` returns no matches (silent failures removed)
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- CurvePoint operations throw on failure instead of silently continuing
- Vault decryption errors are properly categorized
- No TypeScript errors introduced
</success_criteria>

<output>
After completion, create `.planning/phases/01-interface-hardening/01-03-SUMMARY.md`
</output>
