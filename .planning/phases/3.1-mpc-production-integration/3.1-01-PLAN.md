---
phase: 3.1-mpc-production-integration
plan: 01
type: execute
---

<objective>
Connect AGIdentity to real MPC system so the AI agent can use threshold signatures.

Purpose: Enable MPCAgentWallet to use actual MPC threshold signing instead of stubs - the agent starts up, connects to cosigners, and can sign immediately.
Output: Working `createProductionMPCWallet()` factory function with live integration test proving DKG and signing work.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 3.1 research and context:
@.planning/phases/3.1-mpc-production-integration/3.1-RESEARCH.md
@.planning/phases/3.1-mpc-production-integration/3.1-CONTEXT.md

# Prior phase - created MPCAgentWallet with dependency injection:
@.planning/phases/03-mpc-wallet-interface/03-01-SUMMARY.md

# Key source files:
@src/wallet/mpc-agent-wallet.ts
@MPC-DEV/wallet-toolbox-mpc/src/mpc/index.ts
@MPC-DEV/wallet-toolbox-mpc/src/mpc/MPCWallet.ts

**Tech stack available:** MPCAgentWallet with IMPCWallet interface, dependency injection pattern
**Established patterns:** Signing lock for concurrent protection, interface-first design
**Constraining decisions:**
- Phase 03-01: MPCAgentWallet uses dependency injection - external MPC implementation injected at runtime
- CONTEXT.md: Single startup function handles DKG vs restore automatically
- CONTEXT.md: Config via environment variables only

**From RESEARCH.md - Don't Hand-Roll:**
- DKG protocol → use MPCKeyGenerator from wallet-toolbox-mpc
- MPC signing → use MPCSigningCoordinator
- Share encryption → use encryptShare/decryptShare
- WASM loading → use loadWasmModule()
</context>

<tasks>

<task type="auto">
  <name>Task 1: Link wallet-toolbox-mpc as file dependency</name>
  <files>package.json</files>
  <action>
Add wallet-toolbox-mpc as a file dependency pointing to MPC-DEV/wallet-toolbox-mpc.

In package.json dependencies, add:
```json
"@bsv/wallet-toolbox-mpc": "file:./MPC-DEV/wallet-toolbox-mpc"
```

Then run `npm install` to link the package.

IMPORTANT: Use relative path `./MPC-DEV/wallet-toolbox-mpc` (not absolute) so it works across machines.

Do NOT copy the files - use file dependency so updates to MPC-DEV are reflected immediately.
  </action>
  <verify>
npm ls @bsv/wallet-toolbox-mpc shows the linked package
node -e "require('@bsv/wallet-toolbox-mpc')" exits without error
  </verify>
  <done>wallet-toolbox-mpc linked as dependency, imports resolve correctly</done>
</task>

<task type="auto">
  <name>Task 2: Create production MPC wallet factory</name>
  <files>src/wallet/mpc-integration.ts, src/wallet/index.ts</files>
  <action>
Create `src/wallet/mpc-integration.ts` with:

1. **ProductionMPCConfig interface:**
   - walletId: string
   - cosignerEndpoints: string[]
   - shareSecret: string (for share encryption)
   - jwtSecret: string (for cosigner auth)
   - network?: 'mainnet' | 'testnet'
   - storagePath?: string
   - onProgress?: (info: DKGProgressInfo) => void

2. **loadMPCConfigFromEnv() function:**
   - MPC_WALLET_ID (default: 'agent-wallet')
   - MPC_COSIGNER_ENDPOINTS (comma-separated, required)
   - MPC_SHARE_SECRET (required)
   - MPC_JWT_SECRET (required)
   - MPC_NETWORK (default: 'mainnet')
   - MPC_STORAGE_PATH (default: './data/mpc-wallet.sqlite')
   - Throw clear errors for missing required env vars

3. **createProductionMPCWallet(config) function:**
   - Initialize knex with SQLite at storagePath
   - Create MPCPersistence instance
   - Check persistence.loadShare(walletId, 0) for existing share
   - **If share exists (restore path):**
     - Verify password with DerivationEncryption.verifyPassword()
     - Decrypt share with decryptShare()
     - Create MPCClient, initialize with share bytes
     - Load share, metadata, auxiliaryKeys into WASM
     - Create MPCKeyDeriver with restored state
     - Create and return MPCWallet
   - **If no share (DKG path):**
     - Call MPCWallet.create() which handles full DKG
     - Return the created wallet
   - Return { wallet: MPCWallet, isNewWallet: boolean }

4. **Export from src/wallet/index.ts:**
   - createProductionMPCWallet
   - loadMPCConfigFromEnv
   - ProductionMPCConfig type

Import from '@bsv/wallet-toolbox-mpc' (the linked package):
- MPCWallet, MPCClient, MPCPersistence, MPCKeyDeriver
- decryptShare, DerivationEncryption
- DKGProgressInfo type

CRITICAL from RESEARCH.md pitfalls:
- Always check loadShare() BEFORE calling MPCWallet.create() - running DKG when share exists breaks wallet permanently
- Verify password before decryption - wrong password produces garbage shares
- Load auxiliaryKeys after restore - without them, signing fails with cryptic errors
  </action>
  <verify>
npx tsc --noEmit passes without errors
grep -q "createProductionMPCWallet" src/wallet/index.ts
  </verify>
  <done>Production factory function created with DKG vs restore logic, env config loading, proper error handling</done>
</task>

<task type="auto">
  <name>Task 3: Live integration test with real cosigners</name>
  <files>src/wallet/mpc-agent-wallet.test.ts</files>
  <action>
Create integration test that runs with real cosigner servers.

1. **Test file structure:**
```typescript
import { createProductionMPCWallet, loadMPCConfigFromEnv } from './mpc-integration.js'
import { spawn, ChildProcess } from 'child_process'
import path from 'path'
import fs from 'fs'

describe('MPC Production Integration', () => {
  let cosigners: ChildProcess[] = []
  const testDbPath = './test-data/mpc-integration-test.sqlite'

  beforeAll(async () => {
    // Start cosigner servers
    // Clean up test database
  }, 60000) // 60s timeout for startup

  afterAll(async () => {
    // Stop cosigners
    // Clean up test files
  })

  test('DKG creates new wallet and can sign', async () => {
    // Test new wallet creation via DKG
  }, 120000) // 2 min timeout for DKG + signing

  test('Restore loads existing wallet', async () => {
    // Test wallet restoration
  }, 60000)
})
```

2. **Cosigner startup:**
   - Start 2 cosigner processes from MPC-DEV/mpc-test-app/cosigner-servers
   - Use ports 18081 and 18082 (avoid conflict with other services)
   - Wait for servers to be ready (poll /health or similar)
   - Set environment: COSIGNER_PORT, COSIGNER_PARTY_ID, JWT_SECRET

3. **DKG test:**
   - Set test env vars (MPC_COSIGNER_ENDPOINTS, MPC_SHARE_SECRET, etc.)
   - Call createProductionMPCWallet()
   - Assert isNewWallet === true
   - Get identity public key from wallet
   - Sign a test message using wallet.createSignature()
   - Verify signature is valid (64+ bytes, proper format)

4. **Restore test:**
   - Call createProductionMPCWallet() again with same config
   - Assert isNewWallet === false
   - Verify identity key matches the one from DKG
   - Sign another message, verify it works

5. **Test cleanup:**
   - Kill cosigner processes
   - Remove test database file
   - Clear test directories

Run with: `npm test -- --testPathPattern=mpc-agent-wallet.test`

IMPORTANT:
- Use 120s timeout for DKG test (DKG takes ~5s, but allow margin)
- Use unique test database path to avoid conflicts
- Clean up processes even if tests fail (use try/finally or afterAll)
  </action>
  <verify>
npm test -- --testPathPattern=mpc-agent-wallet.test passes
Test output shows "DKG creates new wallet" and "Restore loads existing wallet" passing
  </verify>
  <done>Live integration test passes - DKG creates wallet, signing works, restore preserves identity</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npx tsc --noEmit` passes
- [ ] Integration test passes with real cosigners
- [ ] createProductionMPCWallet() handles both DKG and restore paths
- [ ] Environment variable configuration works correctly
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors
- Live integration test proves:
  - DKG creates new wallet with threshold signatures
  - Wallet can sign messages
  - Restore path loads existing wallet correctly
  - Identity key is preserved across restarts
</success_criteria>

<output>
After completion, create `.planning/phases/3.1-mpc-production-integration/3.1-01-SUMMARY.md`:

# Phase 3.1 Plan 01: MPC Production Integration Summary

**[Substantive one-liner - what shipped]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.ts` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Phase 3.1 complete, ready for Phase 4: OpenClaw Gateway
</output>
