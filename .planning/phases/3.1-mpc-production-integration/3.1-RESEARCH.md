# Phase 3.1: MPC Production Integration - Research

**Researched:** 2026-02-15
**Domain:** MPC wallet integration with existing wallet-toolbox-mpc implementation
**Confidence:** HIGH

<research_summary>
## Summary

Researched how to integrate the existing MPC-DEV/wallet-toolbox-mpc system into AGIdentity's MPCAgentWallet. The MPC system is production-ready with working DKG (Distributed Key Generation), threshold signing, and BRC-42 key derivation. The standard approach is to use MPCWallet.create() for new wallets and persistence-based restoration for existing wallets.

Key finding: The wallet-toolbox-mpc already implements the complete flow - DKG, encrypted share storage, and restoration. The integration challenge is bridging the MPCWallet (full BRC-100 implementation) with AGIdentity's MPCAgentWallet (interface wrapper).

**Primary recommendation:** Use MPCWallet from wallet-toolbox-mpc directly via dependency injection. Create a factory function that handles DKG-vs-restore logic internally, checking MPCPersistence.loadShare() to determine which path to take.

</research_summary>

<standard_stack>
## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| wallet-toolbox-mpc | 1.7.14 | MPC wallet implementation | Internal - full MPC-CMP protocol already built |
| @bsv/sdk | 1.9.9 | BSV crypto primitives | Required for key derivation, signing |
| knex | 3.1.0 | Database abstraction | Already used by wallet-toolbox for storage |
| sqlite3 | 5.1.7 | Local persistence | Share storage, derivation cache |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| mpc_wasm.wasm | (bundled) | MPC-CMP protocol in WASM | Always - core cryptographic operations |
| mpc_wasm.mjs | (bundled) | JS bindings for WASM | Always - initializes WASM module |

### Files Required from MPC-DEV
| Path | Purpose |
|------|---------|
| `wallet-toolbox-mpc/src/mpc/` | All MPC modules |
| `wallet-toolbox-mpc/src/mpc/wasm/mpc_wasm.wasm` | WASM binary |
| `wallet-toolbox-mpc/src/mpc/wasm/mpc_wasm.mjs` | WASM loader |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Direct MPCWallet injection | Wrap MPCWallet behind MPCAgentWallet | More abstraction but MPCAgentWallet already does this |
| npm link | Copy files into AGIdentity | Link easier for dev, copy better for deployment |
| Full factory function | Direct MPCWallet.create() calls | Factory cleaner for env var handling |

**Installation:**
```bash
# Option 1: npm link (development)
cd MPC-DEV/wallet-toolbox-mpc && npm link
cd ../agidentity && npm link @bsv/wallet-toolbox-mpc

# Option 2: File dependency (package.json)
"dependencies": {
  "@bsv/wallet-toolbox-mpc": "file:../MPC-DEV/wallet-toolbox-mpc"
}

# Option 3: Copy files (deployment - recommended)
cp -r MPC-DEV/wallet-toolbox-mpc/src/mpc src/mpc-internal/
cp MPC-DEV/wallet-toolbox-mpc/src/mpc/wasm/mpc_wasm.* src/mpc-internal/wasm/
```
</standard_stack>

<architecture_patterns>
## Architecture Patterns

### Recommended Project Structure
```
src/wallet/
├── mpc-agent-wallet.ts      # Existing - interface wrapper (keep)
├── mpc-integration.ts       # NEW - production factory function
└── mpc-internal/            # NEW - copied from wallet-toolbox-mpc
    ├── MPCWallet.ts
    ├── MPCClient.ts
    ├── MPCPersistence.ts
    ├── MPCKeyDeriver.ts
    └── wasm/
        ├── mpc_wasm.wasm
        ├── mpc_wasm.mjs
        └── WasmLoader.ts
```

### Pattern 1: DKG vs Restore Detection
**What:** Check persistence for existing share before running DKG
**When to use:** Every wallet initialization
**Example:**
```typescript
// Source: MPC-DEV analysis - this pattern is implicit in MPCWallet.create()
// but needs explicit handling for AGIdentity's startup flow

async function initializeMPCWallet(config: ProductionMPCConfig): Promise<MPCWallet> {
  const persistence = new MPCPersistence(knex)
  const existingShare = await persistence.loadShare(config.walletId, 0)

  if (existingShare) {
    // Restore path: decrypt share, load into client, create wallet
    const shareBytes = decryptShare(existingShare.encryptedShare, config.userPassword)
    const mpcClient = new MPCClient(mpcConfig)
    await mpcClient.initialize(shareBytes)
    await mpcClient.loadShareIntoWASM(config.walletId, 0)
    // ... create MPCWallet with restored state
  } else {
    // DKG path: run full distributed key generation
    return await MPCWallet.create(config)
  }
}
```

### Pattern 2: Environment-Based Configuration
**What:** Load MPC config entirely from environment variables
**When to use:** Production deployments
**Example:**
```typescript
// Source: Phase 3.1-CONTEXT.md user requirements

interface ProductionMPCConfig {
  walletId: string         // MPC_WALLET_ID
  cosignerEndpoints: string[] // MPC_COSIGNER_ENDPOINTS (comma-separated)
  shareSecret: string      // MPC_SHARE_SECRET
  jwtSecret: string        // MPC_JWT_SECRET
  storagePath: string      // MPC_STORAGE_PATH
}

function loadConfigFromEnv(): ProductionMPCConfig {
  const endpoints = process.env.MPC_COSIGNER_ENDPOINTS?.split(',') ?? []
  if (endpoints.length === 0) {
    throw new Error('MPC_COSIGNER_ENDPOINTS required')
  }
  return {
    walletId: process.env.MPC_WALLET_ID ?? 'agent-001',
    cosignerEndpoints: endpoints,
    shareSecret: requireEnv('MPC_SHARE_SECRET'),
    jwtSecret: requireEnv('MPC_JWT_SECRET'),
    storagePath: process.env.MPC_STORAGE_PATH ?? './mpc-wallet.sqlite'
  }
}
```

### Pattern 3: Signing Lock for Concurrent Protection
**What:** Serialize MPC signing operations to prevent WASM state corruption
**When to use:** Always - WASM is single-threaded
**Example:**
```typescript
// Source: Already implemented in MPCAgentWallet.withSigningLock()
// CRITICAL: Keep this pattern - concurrent signing corrupts WASM state

private signingLock: Promise<void> = Promise.resolve()

private async withSigningLock<T>(operation: () => Promise<T>): Promise<T> {
  const currentLock = this.signingLock
  let releaseLock: () => void

  this.signingLock = new Promise<void>(resolve => { releaseLock = resolve })

  try {
    await currentLock
    return await operation()
  } finally {
    releaseLock!()
  }
}
```

### Anti-Patterns to Avoid
- **Running DKG when share exists:** Overwrites cosigner shares, breaks wallet permanently
- **Concurrent MPC operations:** WASM state corruption - signatures fail or produce wrong values
- **Hardcoding cosigner URLs:** Use env vars for deployment flexibility
- **Skipping password verification:** Incorrect password → corrupt decrypted share → signing fails with cryptic errors
</architecture_patterns>

<dont_hand_roll>
## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| DKG protocol | Custom 5-round implementation | MPCKeyGenerator from wallet-toolbox-mpc | 5-round protocol with ZK proofs, Paillier encryption - complex crypto |
| MPC signing | Custom threshold signature | MPCSigningCoordinator from wallet-toolbox-mpc | MTA protocol, partial signature aggregation - proven correct |
| Share encryption | Custom encryption | encryptShare/decryptShare from wallet-toolbox-mpc | AES-256-GCM with proper key derivation |
| WASM loading | Custom loader | loadWasmModule() from WasmLoader.ts | Handles caching, error recovery, module validation |
| BRC-42 derivation | Custom ECDH | MPCKeyDeriver with distributed ECDH | Distributed computation - each party contributes partial ECDH |
| Persistence layer | Custom DB schema | MPCPersistence with mpc_shares/mpc_derivations tables | Schema migrations, encryption integration already done |

**Key insight:** The wallet-toolbox-mpc is 94KB+ of production-tested MPC code implementing the CMP protocol. Re-implementing any of this would take weeks and introduce security risks. The integration task is "how to wire it up", not "how to build MPC".

</dont_hand_roll>

<common_pitfalls>
## Common Pitfalls

### Pitfall 1: Share/Cosigner Mismatch
**What goes wrong:** Backend has Wallet A share, cosigners have Wallet B shares from a fresh DKG
**Why it happens:** Running DKG when share exists but storage was cleared, without cosigner reset
**How to avoid:** Always check persistence.loadShare() before calling MPCWallet.create()
**Warning signs:** "Parties disagree on collective public key" or signing produces invalid signatures

### Pitfall 2: Missing WASM Files
**What goes wrong:** "Failed to load MPC WASM module" error at runtime
**Why it happens:** mpc_wasm.wasm and mpc_wasm.mjs not copied to correct location
**How to avoid:** Copy both files from wallet-toolbox-mpc/src/mpc/wasm/ to same relative path
**Warning signs:** Error mentions "Ensure mpc_wasm.wasm and mpc_wasm.mjs are present"

### Pitfall 3: Concurrent Signing Corruption
**What goes wrong:** Signatures fail or verify as invalid intermittently
**Why it happens:** Multiple async operations access WASM state concurrently
**How to avoid:** Use withSigningLock() wrapper for all createSignature/createAction calls
**Warning signs:** Works in serial tests, fails under load

### Pitfall 4: Password Verification Skipped
**What goes wrong:** Share decryption produces garbage, signing fails with "invalid key share"
**Why it happens:** Wrong password used without verification, decryption "succeeds" but produces random bytes
**How to avoid:** Use DerivationEncryption.verifyPassword() before decryption, check passwordVerification field
**Warning signs:** decryptShare() returns without error but signatures fail

### Pitfall 5: Cosigner Auth Token Expiry
**What goes wrong:** DKG or signing fails mid-protocol with 401/403 errors
**Why it happens:** JWT token expires during 5-round protocol (rounds take ~4 seconds total)
**How to avoid:** Use long-lived tokens (>1 hour) or refresh token mechanism
**Warning signs:** Works on first call, fails on subsequent calls in same session

### Pitfall 6: Missing Auxiliary Keys
**What goes wrong:** Signing fails with "cannot verify MTA proofs" or similar
**Why it happens:** auxiliaryKeys (Paillier/Ring-Pedersen secrets) not loaded after restore
**How to avoid:** Load auxiliaryKeys from persistence and inject into MPCClient after share restoration
**Warning signs:** DKG-created wallet works, restored wallet signing fails

</common_pitfalls>

<code_examples>
## Code Examples

Verified patterns from wallet-toolbox-mpc implementation:

### Production Factory Function (Template)
```typescript
// Source: Derived from MPCWallet.create() and 3.1-CONTEXT.md requirements

export interface ProductionMPCConfig {
  walletId: string
  cosignerEndpoints: string[]
  shareSecret: string      // User password for share encryption
  jwtSecret: string        // For cosigner authentication
  network?: 'mainnet' | 'testnet'
  storagePath?: string
  onProgress?: (info: DKGProgressInfo) => void
}

export async function createProductionMPCWallet(
  config: ProductionMPCConfig
): Promise<{ wallet: MPCWallet; isNewWallet: boolean }> {
  const knexInstance = knex({
    client: 'sqlite3',
    connection: { filename: config.storagePath ?? './mpc-wallet.sqlite' },
    useNullAsDefault: true,
  })

  // Run migrations for MPC tables
  await runMPCMigrations(knexInstance)

  const persistence = new MPCPersistence(knexInstance)
  const existingShare = await persistence.loadShare(config.walletId, 0)

  if (existingShare) {
    // RESTORE PATH
    return {
      wallet: await restoreExistingWallet(config, existingShare, persistence, knexInstance),
      isNewWallet: false
    }
  } else {
    // DKG PATH
    return {
      wallet: await createNewWallet(config, persistence, knexInstance),
      isNewWallet: true
    }
  }
}
```

### Restore Existing Wallet
```typescript
// Source: Derived from MPCWallet.create() share loading logic

async function restoreExistingWallet(
  config: ProductionMPCConfig,
  storedShare: StoredShare,
  persistence: MPCPersistence,
  knex: Knex
): Promise<MPCWallet> {
  // Verify password before decryption
  if (storedShare.passwordVerification) {
    const encSalt = Buffer.from(storedShare.derivationEncSalt!, 'hex')
    const hmacSalt = Buffer.from(storedShare.derivationHmacSalt!, 'hex')
    const passwordCorrect = DerivationEncryption.verifyPassword(
      storedShare.passwordVerification,
      config.shareSecret,
      encSalt,
      hmacSalt
    )
    if (!passwordCorrect) {
      throw new Error('Invalid password for wallet restoration')
    }
  }

  // Decrypt share
  const shareBytes = decryptShare(storedShare.encryptedShare, config.shareSecret)

  // Initialize MPC client with share
  const mpcConfig: MPCConfig = {
    partyId: '1',
    totalParties: storedShare.totalParties,
    threshold: storedShare.threshold,
    parties: buildPartiesArray(config.cosignerEndpoints),
    jwtToken: generateJWT(config.jwtSecret)
  }

  const mpcClient = new MPCClient(mpcConfig)
  await mpcClient.initialize(shareBytes)

  // Load share and auxiliary keys into WASM
  await mpcClient.loadShareIntoWASM(config.walletId, 0)
  if (storedShare.mpcMetadata) {
    await mpcClient.loadMetadataIntoWASM(config.walletId, 0, storedShare.mpcMetadata)
  }
  if (storedShare.auxiliaryKeys) {
    await mpcClient.loadAuxiliaryKeysIntoWASM(config.walletId, 0, storedShare.auxiliaryKeys)
  }

  // Create storage and key deriver
  const storage = await createStorageManager(knex, storedShare.collectivePublicKey)
  const keyId: MPCKeyId = {
    walletId: config.walletId,
    keyIndex: 0,
    collectivePublicKey: storedShare.collectivePublicKey
  }
  const keyDeriver = new MPCKeyDeriver(mpcClient, keyId, persistence)

  return new MPCWallet({
    chain: config.network === 'testnet' ? 'test' : 'main',
    keyDeriver,
    storage,
    mpcClient,
    persistence
  })
}
```

### Environment Variable Loading
```typescript
// Source: 3.1-CONTEXT.md requirements

function loadMPCConfigFromEnv(): ProductionMPCConfig {
  const requireEnv = (key: string): string => {
    const value = process.env[key]
    if (!value) throw new Error(`Required environment variable ${key} not set`)
    return value
  }

  const endpoints = process.env.MPC_COSIGNER_ENDPOINTS?.split(',').map(s => s.trim()) ?? []
  if (endpoints.length === 0) {
    throw new Error('MPC_COSIGNER_ENDPOINTS must contain at least one endpoint')
  }

  return {
    walletId: process.env.MPC_WALLET_ID ?? 'agent-wallet',
    cosignerEndpoints: endpoints,
    shareSecret: requireEnv('MPC_SHARE_SECRET'),
    jwtSecret: requireEnv('MPC_JWT_SECRET'),
    network: process.env.MPC_NETWORK === 'testnet' ? 'testnet' : 'mainnet',
    storagePath: process.env.MPC_STORAGE_PATH ?? './data/mpc-wallet.sqlite',
  }
}
```

</code_examples>

<sota_updates>
## State of the Art (2025-2026)

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| External MPC services (Fireblocks) | Self-hosted MPC with wallet-toolbox-mpc | 2025 | Full control, no vendor lock-in |
| Single-key wallets for AI | MPC threshold wallets | 2025 | Key exfiltration impossible |
| HSM-based key storage | Distributed MPC shares | 2024 | Geographic distribution, no SPOF |

**New tools/patterns to consider:**
- **MPCWallet.restoreFromBackup():** Static method for disaster recovery - not needed for normal restore
- **ConsolidationService:** UTXO consolidation with free BSV transactions - available but not urgent
- **DerivationEncryption:** Password-based encryption for derivation cache - already integrated

**Deprecated/outdated:**
- **MPCAgentWallet stub implementation:** Phase 3 created stubs - replace with real injection
- **Mock MPC wallet for testing:** Use actual MPC with local cosigners instead

</sota_updates>

<open_questions>
## Open Questions

Things that couldn't be fully resolved:

1. **Cosigner deployment location for AI agent**
   - What we know: Cosigners must be separate processes, can be same machine or different
   - What's unclear: Where should AGIdentity's cosigners run? Same Docker network? Different VMs?
   - Recommendation: Start with local cosigners (separate processes), move to separate VMs for production

2. **JWT token generation for cosigner auth**
   - What we know: Cosigners require JWT auth with MPC_JWT_SECRET
   - What's unclear: How should AGIdentity generate/refresh tokens? Who issues them?
   - Recommendation: Generate long-lived tokens locally from MPC_JWT_SECRET, no external auth service needed for initial implementation

3. **Multi-agent scenarios**
   - What we know: Current design is single wallet per agent instance
   - What's unclear: What if multiple AI agents share one wallet? Or one agent manages multiple wallets?
   - Recommendation: Out of scope per CONTEXT.md - single wallet only for Phase 3.1

</open_questions>

<sources>
## Sources

### Primary (HIGH confidence)
- MPC-DEV/wallet-toolbox-mpc/src/mpc/MPCWallet.ts - create(), restore flow
- MPC-DEV/wallet-toolbox-mpc/src/mpc/MPCPersistence.ts - share storage, loadShare()
- MPC-DEV/wallet-toolbox-mpc/src/mpc/types.ts - MPCWalletCreateConfig interface
- MPC-DEV/README.md - System overview, test instructions
- MPC-DEV/docs/production-mpc-architecture.md - Architecture blueprint

### Secondary (MEDIUM confidence)
- src/wallet/mpc-agent-wallet.ts - Current AGIdentity implementation
- .planning/phases/3.1-mpc-production-integration/3.1-CONTEXT.md - User requirements

### Tertiary (LOW confidence - needs validation)
- None - all findings from internal codebase

</sources>

<metadata>
## Metadata

**Research scope:**
- Core technology: wallet-toolbox-mpc MPC-CMP implementation
- Ecosystem: Already bundled - no external libraries needed
- Patterns: DKG vs restore, env config, signing lock
- Pitfalls: Share mismatch, WASM loading, concurrent access

**Confidence breakdown:**
- Standard stack: HIGH - using internal implementation
- Architecture: HIGH - patterns from working code
- Pitfalls: HIGH - documented in production-mpc-architecture.md
- Code examples: HIGH - derived from actual implementation

**Research date:** 2026-02-15
**Valid until:** 2026-03-15 (30 days - internal code, stable)

</metadata>

---

*Phase: 3.1-mpc-production-integration*
*Research completed: 2026-02-15*
*Ready for planning: yes*
