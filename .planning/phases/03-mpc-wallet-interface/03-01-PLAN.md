---
phase: 03-mpc-wallet-interface
plan: 01
type: execute
---

<objective>
Create MPCAgentWallet class that implements BRC100Wallet using MPC threshold signatures.

Purpose: Enable AGIdentity's AI agent to sign transactions and messages without any single party having access to the full private key. The MPC wallet coordinates with external cosigner servers for all cryptographic operations.

Output: Working MPCAgentWallet class that can be used anywhere AgentWallet is used today, with MPC security underneath.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-mpc-wallet-interface/03-RESEARCH.md
@.planning/phases/03-mpc-wallet/03-CONTEXT.md
@.planning/phases/02-messagebox-channel/02-03-SUMMARY.md

@src/wallet/agent-wallet.ts
@src/wallet/index.ts
@src/types/index.ts

**Tech stack available:**
- @bsv/wallet-toolbox (includes MPC modules at /out/src/mpc/*)
- @bsv/sdk
- knex for SQLite persistence

**Established patterns:**
- BRC100Wallet interface for wallet abstraction
- AgentWallet as reference implementation
- Factory functions (createAgentWallet pattern)

**Constraining decisions:**
- MPC for AI wallet - prevents key exfiltration even if AI compromised
- AGIdentity owns the wallet - MPCWallet instance created/managed by AGIdentity

**From RESEARCH.md (critical):**
- Import from `@bsv/wallet-toolbox/out/src/mpc/*` (NOT separate package)
- MPCWallet.create() for new wallets (5-round DKG)
- Manual restoration for existing wallets (share → metadata → auxiliary keys → derivations)
- Signing lock pattern required for concurrent operations
- Key ID format: `walletId:keyIndex`
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MPCAgentWallet class implementing BRC100Wallet</name>
  <files>src/wallet/mpc-agent-wallet.ts</files>
  <action>
Create MPCAgentWallet class that:

1. **Implements BRC100Wallet interface** - Same interface as AgentWallet for drop-in replacement

2. **Configuration** (MPCAgentWalletConfig):
   - `walletId: string` - Unique wallet identifier
   - `cosignerEndpoints: string[]` - URLs of cosigner servers (e.g., ['http://localhost:8081', 'http://localhost:8082'])
   - `shareSecret: string` - Secret for encrypting share at rest (from env/secrets manager)
   - `jwtSecret: string` - Secret for JWT auth with cosigners
   - `network?: 'mainnet' | 'testnet'` - Defaults to mainnet
   - `storagePath?: string` - SQLite database path (defaults to './mpc-wallet.sqlite')

3. **Initialization flow** (in initialize() method):
   - Create Knex instance for SQLite storage
   - Create StorageKnex and WalletStorageManager
   - Generate JWT token for cosigner auth
   - Create MPCClient with party config (user is party 1, cosigners are 2, 3, ...)
   - Create MPCPersistence
   - Check for existing share:
     - **If exists:** Restore wallet (decrypt share, load into WASM, load metadata, load auxiliary keys, initialize keyDeriver, restore derivations)
     - **If not exists:** Create via MPCWallet.create() with DKG
   - Store identity public key for getPublicKey({ identityKey: true })

4. **Signing lock pattern** - Private `withSigningLock<T>()` method to serialize signing operations:
   ```typescript
   private signingLock: Promise<void> = Promise.resolve()

   private async withSigningLock<T>(operation: () => Promise<T>): Promise<T> {
     const currentLock = this.signingLock
     let releaseLock: () => void
     this.signingLock = new Promise<void>((resolve) => { releaseLock = resolve })
     try {
       await currentLock
       return await operation()
     } finally {
       releaseLock!()
     }
   }
   ```

5. **BRC100Wallet methods** - Delegate to underlying MPCWallet:
   - `getPublicKey()` - Return identity key or derive with protocolID/keyID
   - `encrypt()` / `decrypt()` - Use wallet.encrypt/decrypt
   - `createSignature()` - **Wrap in withSigningLock()**, use wallet.createSignature
   - `verifySignature()` - Use wallet.verifySignature (no lock needed, local verification)
   - `createHmac()` / `verifyHmac()` - Use wallet methods
   - `createAction()` - **Wrap in withSigningLock()**, use wallet.createAction
   - `acquireCertificate()` / `listCertificates()` - Use wallet methods
   - `getNetwork()` - Return configured network
   - `getHeight()` - Use wallet.getHeight
   - `isAuthenticated()` - Return initialization status

6. **Additional methods**:
   - `getCollectivePublicKey(): string` - Return the MPC collective public key
   - `destroy(): Promise<void>` - Clean up resources (wallet.destroy if available)

**Import paths (CRITICAL - from RESEARCH.md):**
```typescript
import { MPCWallet } from '@bsv/wallet-toolbox/out/src/mpc/MPCWallet'
import { MPCClient } from '@bsv/wallet-toolbox/out/src/mpc/MPCClient'
import { MPCKeyDeriver } from '@bsv/wallet-toolbox/out/src/mpc/MPCKeyDeriver'
import { MPCPersistence } from '@bsv/wallet-toolbox/out/src/mpc/MPCPersistence'
import { decryptShare } from '@bsv/wallet-toolbox/out/src/mpc/utils/shareEncryption'
import type { MPCKeyId, DKGProgressInfo } from '@bsv/wallet-toolbox/out/src/mpc/types'
import { WalletStorageManager, StorageKnex, Services } from '@bsv/wallet-toolbox'
import { knex as makeKnex } from 'knex'
```

**What NOT to do:**
- Don't import from 'wallet-toolbox-mpc' - it doesn't exist, use @bsv/wallet-toolbox
- Don't skip the signing lock - concurrent MPC operations corrupt state
- Don't forget to load auxiliary keys - signing verification will fail
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit src/wallet/mpc-agent-wallet.ts`</verify>
  <done>MPCAgentWallet class exists, implements BRC100Wallet, handles DKG/restore, has signing lock</done>
</task>

<task type="auto">
  <name>Task 2: Add factory function and exports</name>
  <files>src/wallet/mpc-agent-wallet.ts, src/wallet/index.ts, src/index.ts</files>
  <action>
1. **Add factory function** to mpc-agent-wallet.ts:
```typescript
/**
 * Create an MPC-secured agent wallet
 *
 * @example
 * ```typescript
 * const { wallet } = await createMPCAgentWallet({
 *   walletId: 'ai-agent-001',
 *   cosignerEndpoints: ['http://localhost:8081', 'http://localhost:8082'],
 *   shareSecret: process.env.MPC_SHARE_SECRET!,
 *   jwtSecret: process.env.MPC_JWT_SECRET!,
 *   network: 'mainnet'
 * });
 *
 * // Use like any BRC100Wallet
 * const sig = await wallet.createSignature({ ... });
 * ```
 */
export async function createMPCAgentWallet(
  config: MPCAgentWalletConfig
): Promise<{ wallet: MPCAgentWallet }> {
  const wallet = new MPCAgentWallet(config)
  await wallet.initialize()
  return { wallet }
}
```

2. **Export from src/wallet/index.ts**:
```typescript
export {
  MPCAgentWallet,
  createMPCAgentWallet,
  type MPCAgentWalletConfig
} from './mpc-agent-wallet.js'
```

3. **Re-export from src/index.ts** - Add to existing exports:
```typescript
// In the wallet section
export {
  AgentWallet,
  createAgentWallet,
  MPCAgentWallet,
  createMPCAgentWallet,
  type MPCAgentWalletConfig
} from './wallet/index.js'
```
  </action>
  <verify>
Package builds: `npm run build` succeeds.
Exports accessible: `node -e "import('@anthropic/agidentity').then(m => console.log('MPCAgentWallet:', typeof m.MPCAgentWallet))"`
  </verify>
  <done>Factory function exists, exports work from package entry point</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npx tsc --noEmit` passes type checking
- [ ] MPCAgentWallet implements all BRC100Wallet methods
- [ ] Signing lock pattern implemented for createSignature and createAction
- [ ] Factory function createMPCAgentWallet exported from package
</verification>

<success_criteria>

- MPCAgentWallet class created implementing BRC100Wallet
- Handles both new wallet (DKG) and existing wallet (restore) flows
- Signing lock prevents concurrent MPC operation corruption
- Factory function and exports work
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-mpc-wallet-interface/03-01-SUMMARY.md`
</output>
