#!/usr/bin/env node
/**
 * AGIdentity Gateway - Start Script
 *
 * Usage:
 *   npm run gateway
 *
 * On first run (interactive TTY), launches the setup wizard which configures
 * everything and saves to ~/.agidentity/config.json + ~/.agidentity/.env.
 *
 * On subsequent runs, loads config from those files. Environment variables
 * override config file values where set.
 */

import * as fs from 'fs';
import * as path from 'path';
import * as http from 'http';

// Load ~/.agidentity/.env first (user-generated by setup wizard)
const agidEnvPath = path.join(process.env.HOME || '/tmp', '.agidentity', '.env');
if (fs.existsSync(agidEnvPath)) {
  const dotenv = await import('dotenv');
  dotenv.config({ path: agidEnvPath });
}

// Then load project .env (overrides agidentity .env where set)
import 'dotenv/config';

import { createAGIdentityGateway } from './gateway/index.js';
import { createProvider } from './agent/providers/index.js';
import { createAgentWallet } from './wallet/agent-wallet.js';
import type { AgentWallet } from './wallet/agent-wallet.js';
import {
  runFirstRunSetup,
  loadCertConfig,
  loadGatewayConfig,
  type GatewayConfig,
} from './startup/first-run-setup.js';

async function main() {
  console.log('');
  console.log('╔═══════════════════════════════════════════════════════════╗');
  console.log('║                    AGIdentity Gateway                      ║');
  console.log('║         Enterprise AI with Cryptographic Identity          ║');
  console.log('╚═══════════════════════════════════════════════════════════╝');
  console.log('');

  // -----------------------------------------------------------------------
  // Load or create configuration
  // -----------------------------------------------------------------------
  let gatewayConfig: GatewayConfig | null = loadGatewayConfig();

  if (!gatewayConfig && process.stdin.isTTY) {
    // First run — interactive setup
    try {
      // Setup wizard handles key generation, LLM config, certs, and funding.
      // It derives the agent public key from the private key internally.
      const result = await runFirstRunSetup();
      gatewayConfig = result.gatewayConfig;

      // Re-load env vars that the setup wizard wrote
      if (fs.existsSync(agidEnvPath)) {
        const dotenv = await import('dotenv');
        dotenv.config({ path: agidEnvPath, override: true });
      }
    } catch (err) {
      console.error('Setup failed:', err instanceof Error ? err.message : err);
      process.exit(1);
    }
  } else if (!gatewayConfig) {
    console.log('No config.json found (non-interactive mode — using environment variables)');
  }

  // -----------------------------------------------------------------------
  // Resolve configuration: config file values, env vars override
  // -----------------------------------------------------------------------
  const privateKey = process.env.AGENT_PRIVATE_KEY ?? gatewayConfig?.privateKey;
  const network = (process.env.AGID_NETWORK as 'mainnet' | 'testnet') ?? gatewayConfig?.network ?? 'mainnet';
  const storageMode = (process.env.AGID_STORAGE_MODE as 'local' | 'remote') ?? gatewayConfig?.storageMode;
  const storagePath = process.env.AGID_STORAGE_PATH ?? gatewayConfig?.storagePath;
  const storageUrl = process.env.AGID_STORAGE_URL ?? gatewayConfig?.storageUrl;

  // LLM — env vars take priority
  const hasAnthropicEnv = !!process.env.ANTHROPIC_API_KEY;
  const hasExplicitProvider = !!process.env.AGID_LLM_PROVIDER;
  const hasBaseUrl = !!process.env.AGID_LLM_BASE_URL;

  // If no LLM configured via env, apply config file values to process.env
  // so createProvider() picks them up
  if (gatewayConfig && !hasAnthropicEnv && !hasExplicitProvider && !hasBaseUrl) {
    if (gatewayConfig.llmProvider === 'anthropic' && gatewayConfig.llmApiKey) {
      process.env.ANTHROPIC_API_KEY = gatewayConfig.llmApiKey;
    } else if (gatewayConfig.llmProvider === 'ollama') {
      process.env.AGID_LLM_PROVIDER = 'ollama';
      if (gatewayConfig.llmBaseUrl) process.env.AGID_LLM_BASE_URL = gatewayConfig.llmBaseUrl;
      if (gatewayConfig.llmModel) process.env.AGID_MODEL = gatewayConfig.llmModel;
    } else if (gatewayConfig.llmProvider === 'openai-compatible') {
      process.env.AGID_LLM_PROVIDER = 'openai-compatible';
      if (gatewayConfig.llmBaseUrl) process.env.AGID_LLM_BASE_URL = gatewayConfig.llmBaseUrl;
      if (gatewayConfig.llmApiKey) process.env.AGID_LLM_API_KEY = gatewayConfig.llmApiKey;
      if (gatewayConfig.llmModel) process.env.AGID_MODEL = gatewayConfig.llmModel;
    }
  }

  // Re-check after config application
  if (!process.env.ANTHROPIC_API_KEY && !process.env.AGID_LLM_PROVIDER && !process.env.AGID_LLM_BASE_URL) {
    console.error('ERROR: No LLM provider configured');
    console.error('');
    console.error('Set one of:');
    console.error('  ANTHROPIC_API_KEY=<key>                         (Anthropic Claude)');
    console.error('  AGID_LLM_PROVIDER=ollama AGID_MODEL=llama3.1   (Local Ollama)');
    console.error('  AGID_LLM_BASE_URL=http://... AGID_LLM_API_KEY=<key>  (OpenAI-compatible)');
    process.exit(1);
  }

  if (!privateKey) {
    console.error('ERROR: AGENT_PRIVATE_KEY not set');
    console.error('');
    console.error('Generate one with: openssl rand -hex 32');
    console.error('Then set: AGENT_PRIVATE_KEY=<your-64-char-hex>');
    process.exit(1);
  }

  // -----------------------------------------------------------------------
  // Wallet setup
  // -----------------------------------------------------------------------
  console.log('Creating wallet (wallet-toolbox)...');
  let wallet: AgentWallet;
  let identityPublicKey: string;

  const { wallet: agentWallet } = await createAgentWallet({
    privateKeyHex: privateKey,
    network,
    storageMode,
    storagePath,
    storageUrl,
  });
  wallet = agentWallet;
  const keyResult = await agentWallet.getPublicKey({ identityKey: true });
  identityPublicKey = keyResult.publicKey;

  console.log(`Agent Identity: ${identityPublicKey}`);
  console.log('');

  // Load cert config (created during first-run setup if MetaNet Client was available)
  const certConfig = loadCertConfig();
  if (!certConfig) {
    console.warn('No cert-config.json found — delete ~/.agidentity/config.json and re-run interactively to set up certificates');
  }

  // -----------------------------------------------------------------------
  // MessageBox initialization
  // -----------------------------------------------------------------------
  const messageBoxHost = process.env.MESSAGEBOX_HOST || 'https://messagebox.babbage.systems';
  try {
    console.log('Initializing MessageBox...');
    const mbTimeout = parseInt(process.env.MESSAGEBOX_INIT_TIMEOUT || '30000');
    await Promise.race([
      (wallet as any).initializeMessageBox(messageBoxHost),
      new Promise((_, reject) => setTimeout(() => reject(new Error(`MessageBox init timed out after ${mbTimeout}ms`)), mbTimeout)),
    ]);
    console.log(`MessageBox initialized (host: ${messageBoxHost})`);
  } catch (error) {
    console.error('FATAL: MessageBox initialization failed:', error instanceof Error ? error.message : error);
    console.error('   MessageBox is the only communication channel — cannot start without it.');
    console.error(`   Host: ${messageBoxHost}`);
    console.error('   Check network connectivity and MESSAGEBOX_HOST env var.');
    process.exit(1);
  }

  // -----------------------------------------------------------------------
  // Trusted certifiers
  // -----------------------------------------------------------------------
  const trustedCertifiers = process.env.TRUSTED_CERTIFIERS?.split(',').filter(Boolean) || [];

  if (certConfig?.userKey && !trustedCertifiers.includes(certConfig.userKey)) {
    trustedCertifiers.push(certConfig.userKey);
    console.log(`Trusted certifier (from cert-config): ${certConfig.userKey.substring(0, 16)}...`);
  }

  if (trustedCertifiers.length === 0) {
    console.warn('WARNING: No TRUSTED_CERTIFIERS set - all certificates will be rejected');
    console.warn('Add comma-separated CA public keys to .env');
    console.warn('');
  }

  if (process.env.AGID_REQUIRE_CERTS === 'true') {
    console.log('Certificate enforcement: ENABLED');
  }

  // -----------------------------------------------------------------------
  // LLM provider
  // -----------------------------------------------------------------------
  let provider;
  let providerType: string;
  try {
    provider = createProvider();
    providerType = process.env.AGID_LLM_PROVIDER
      ?? (process.env.ANTHROPIC_API_KEY ? 'anthropic' : process.env.AGID_LLM_BASE_URL ? 'ollama' : 'anthropic');
    console.log(`LLM Provider: ${providerType}`);
  } catch (error) {
    console.error('ERROR: Failed to create LLM provider:', error instanceof Error ? error.message : error);
    process.exit(1);
  }

  // -----------------------------------------------------------------------
  // Gateway
  // -----------------------------------------------------------------------
  console.log('Starting native agent gateway...');
  const gateway = await createAGIdentityGateway({
    wallet,
    trustedCertifiers,
    provider,
    model: process.env.AGID_MODEL,
    workspacePath: process.env.AGID_WORKSPACE_PATH,
    sessionsPath: process.env.AGID_SESSIONS_PATH,
    maxIterations: process.env.AGID_MAX_ITERATIONS ? parseInt(process.env.AGID_MAX_ITERATIONS) : undefined,
    maxTokens: process.env.AGID_MAX_TOKENS ? parseInt(process.env.AGID_MAX_TOKENS) : undefined,
    signResponses: true,
    audit: { enabled: true },
    messageBoxes: ['inbox', 'chat'],
  });
  console.log('Agent gateway initialized');

  // -----------------------------------------------------------------------
  // Health check
  // -----------------------------------------------------------------------
  const healthPort = parseInt(process.env.HEALTH_PORT || '3000');
  let healthServer: http.Server | null = null;
  healthServer = http.createServer((_req, res) => {
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({
      status: gateway.isRunning() ? 'healthy' : 'degraded',
      agent: identityPublicKey,
      provider: providerType,
      model: process.env.AGID_MODEL ?? 'default',
      gateway: gateway.isRunning(),
      uptime: process.uptime(),
    }));
  });
  healthServer.on('error', (error: NodeJS.ErrnoException) => {
    if (error.code === 'EADDRINUSE') {
      console.warn(`Health check port ${healthPort} in use — skipping health server`);
    } else {
      console.warn('Health check server failed:', error.message);
    }
    healthServer = null;
  });
  healthServer.listen(healthPort, '0.0.0.0');
  console.log(`Health check on http://0.0.0.0:${healthPort}/`);

  console.log('');
  console.log('===================================================================');
  console.log('Gateway running!');
  console.log('');
  console.log(`  MessageBox: Listening for encrypted messages`);
  console.log(`  Agent Core: ${providerType} (model: ${process.env.AGID_MODEL ?? 'default'})`);
  console.log('===================================================================');
  console.log('');

  // Graceful shutdown
  const shutdown = async () => {
    console.log('');
    console.log('Shutting down...');
    if (healthServer) {
      healthServer.close();
    }
    await gateway.shutdown();
    console.log('Goodbye!');
    process.exit(0);
  };

  process.on('SIGTERM', shutdown);

  console.log('Press Ctrl+C to stop.');
  process.on('SIGINT', shutdown);
  await new Promise(() => {});
}

main().catch((err) => {
  console.error('Fatal error:', err);
  process.exit(1);
});
